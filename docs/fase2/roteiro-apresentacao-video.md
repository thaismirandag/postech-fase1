# üé¨ ROTEIRO PARA APRESENTA√á√ÉO EM V√çDEO - FASE 2
## Sistema de Autoatendimento Fast Food - Tech Challenge FIAP

---

## üìã INFORMA√á√ïES GERAIS

**T√≠tulo:** Demonstra√ß√£o do Sistema de Autoatendimento Fast Food - Fase 2  
**Dura√ß√£o:** 20-25 minutos  
**Plataforma:** Minikube (Kubernetes Local)  
**Foco:** Arquitetura, APIs e Infraestrutura  

---

## üéØ 1. INTRODU√á√ÉO (2-3 minutos)

### Apresenta√ß√£o do Projeto
```
"Ol√°! Sou [Seu Nome] e hoje vou demonstrar o Sistema de Autoatendimento 
Fast Food desenvolvido para a Fase 2 do Tech Challenge da FIAP.

Este projeto resolve um problema real: uma lanchonete em expans√£o que 
precisava de um sistema para controlar pedidos e evitar o caos no 
atendimento."
```

### Problema de Neg√≥cio Identificado
- ‚ùå **Atendimento ca√≥tico** sem sistema de controle
- ‚ùå **Pedidos perdidos** ou mal interpretados
- ‚ùå **Problemas de performance** nos hor√°rios de pico
- ‚ùå **Clientes insatisfeitos** e perda de neg√≥cios

### Solu√ß√£o Implementada
- ‚úÖ **Sistema de autoatendimento** completo
- ‚úÖ **Clean Architecture** com refatora√ß√£o
- ‚úÖ **Kubernetes** com HPA para escalabilidade
- ‚úÖ **Integra√ß√£o Mercado Pago** (mock/real)
- ‚úÖ **APIs robustas** conforme especifica√ß√£o

---

## üèóÔ∏è 2. DEMONSTRA√á√ÉO DA ARQUITETURA (3-4 minutos)

### Mostrar o Diagrama de Arquitetura
```
"Vamos come√ßar visualizando nossa arquitetura completa. Como voc√™s podem 
ver, implementamos uma solu√ß√£o robusta que atende todos os requisitos."
```

**Apresentar:**
- üìä **Diagrama de arquitetura** (PNG)
- ‚ò∏Ô∏è **Componentes Kubernetes** detalhados
- ‚ö° **HPA como solu√ß√£o** para performance
- üåê **Integra√ß√£o com servi√ßos** externos

### Explicar os Componentes Principais
```
"Na infraestrutura Kubernetes temos:
- Namespace isolado para organiza√ß√£o
- Deployment com 2-10 r√©plicas controladas pelo HPA
- Service para load balancing
- ConfigMap e Secret para seguran√ßa
- PostgreSQL com persist√™ncia"
```

**Componentes Destacados:**
- **Namespace:** `fastfood` (isolamento)
- **Deployment:** `fastfood-app` (2-10 r√©plicas)
- **Service:** `fastfood-service` (ClusterIP)
- **HPA:** `fastfood-hpa` (escalabilidade autom√°tica)
- **ConfigMap:** `fastfood-config` (vari√°veis)
- **Secret:** `fastfood-secret` (dados sens√≠veis)

---

## ‚ò∏Ô∏è 3. DEMONSTRA√á√ÉO DO MINIKUBE (4-5 minutos)

### Iniciar Minikube
```bash
# Comandos para mostrar no terminal
minikube start
kubectl get nodes
```

**Explicar:**
```
"Vamos iniciar nosso cluster Kubernetes local usando Minikube. 
Isso simula um ambiente de produ√ß√£o em nossa m√°quina local."
```

### Aplicar Configura√ß√µes Kubernetes
```bash
# Mostrar os arquivos YAML e aplicar
kubectl apply -f backend/k8s/namespace.yaml
kubectl apply -f backend/k8s/configmap.yaml
kubectl apply -f backend/k8s/secret.yaml
kubectl apply -f backend/k8s/app.yaml
```

**Explicar cada arquivo:**
- **namespace.yaml:** Cria√ß√£o do namespace isolado
- **configmap.yaml:** Vari√°veis de ambiente
- **secret.yaml:** Dados sens√≠veis (senhas, tokens)
- **app.yaml:** Deployment, Service e HPA

### Verificar Deploy
```bash
# Mostrar status dos recursos
kubectl get all -n fastfood
kubectl get hpa -n fastfood
kubectl describe deployment fastfood-app -n fastfood
```

### Explicar HPA (Horizontal Pod Autoscaler)
```
"O HPA √© nossa solu√ß√£o para problemas de performance. Ele monitora 
CPU e mem√≥ria e escala automaticamente de 2 a 10 r√©plicas conforme 
a demanda, resolvendo os problemas de lentid√£o nos hor√°rios de pico."
```

**Configura√ß√µes do HPA:**
- **Min Replicas:** 2 (disponibilidade m√≠nima)
- **Max Replicas:** 10 (escala m√°xima)
- **Target CPU:** 70% (escala baseada em CPU)
- **Target Memory:** 80% (escala baseada em mem√≥ria)
- **Scale Up:** 30s (resposta r√°pida)
- **Scale Down:** 300s (estabilidade)

---

## üîß 4. BUILD E DEPLOY DA APLICA√á√ÉO (2-3 minutos)

### Build da Imagem Docker
```bash
# Mostrar no terminal
cd backend
docker build -t fastfood-app:latest .
minikube image load fastfood-app:latest
```

**Explicar:**
```
"Vamos construir nossa imagem Docker e carreg√°-la no Minikube. 
Isso simula o processo de CI/CD em um ambiente real."
```

### Verificar Deploy
```bash
# Mostrar logs e status
kubectl logs -f deployment/fastfood-app -n fastfood
kubectl get pods -n fastfood
```

**Verificar:**
- ‚úÖ Pods em estado Running
- ‚úÖ Logs sem erros
- ‚úÖ Health checks passando

---

## üåê 5. TESTE DAS APIs (6-8 minutos)

### Acessar Swagger UI
```
"Agora vamos testar nossas APIs. Primeiro, vou acessar o Swagger UI 
para demonstrar a documenta√ß√£o interativa."
```

```bash
# Port forward para acessar a aplica√ß√£o
kubectl port-forward -n fastfood svc/fastfood-service 8000:80
```

**Acessar:** `http://localhost:8000/docs`

### Demonstrar APIs P√∫blicas

#### 1. Listar Produtos
```bash
curl -X GET "http://localhost:8000/v1/api/produtos/" \
  -H "accept: application/json"
```

**Explicar:**
```
"Este endpoint retorna todos os produtos dispon√≠veis para o cliente 
escolher no totem de autoatendimento."
```

#### 2. Criar Cliente
```bash
curl -X POST "http://localhost:8000/v1/api/clientes/" \
  -H "Content-Type: application/json" \
  -d '{
    "nome": "Jo√£o Silva",
    "email": "joao@email.com",
    "cpf": "12345678901"
  }'
```

**Explicar:**
```
"O cliente pode se cadastrar opcionalmente. Isso permite campanhas 
promocionais e acompanhamento de pedidos."
```

#### 3. Criar Pedido (Checkout) - REQUISITO i
```bash
curl -X POST "http://localhost:8000/v1/api/pedidos/" \
  -H "Content-Type: application/json" \
  -d '{
    "cliente_id": "uuid-do-cliente",
    "itens": [
      {
        "produto_id": "uuid-do-produto",
        "quantidade": 2
      }
    ],
    "observacoes": "Sem cebola"
  }'
```

**Explicar:**
```
"Este √© o endpoint de checkout que recebe os produtos e retorna a 
identifica√ß√£o do pedido, conforme solicitado nos requisitos da Fase 2."
```

**Resposta Esperada:**
```json
{
  "id": "uuid-do-pedido",
  "cliente_id": "uuid-do-cliente",
  "status": "RECEBIDO",
  "data_criacao": "2025-01-20T10:00:00",
  "itens": [...],
  "valor_total": 25.50
}
```

#### 4. Gerar QR Code - REQUISITO vi (Mercado Pago)
```bash
curl -X GET "http://localhost:8000/v1/api/pagamentos/{pedido_id}/qrcode" \
  -H "accept: application/json"
```

**Explicar:**
```
"O QR Code √© gerado automaticamente com o valor calculado do pedido. 
A integra√ß√£o com Mercado Pago est√° funcionando em modo mock para 
demonstra√ß√£o, mas pode ser facilmente configurada para produ√ß√£o."
```

**Resposta Esperada:**
```json
{
  "id": "uuid-do-pagamento",
  "status": "ok",
  "qrcode_url": "https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=MOCK_PAYMENT_{pedido_id}",
  "qrcode_id": "mock-preference-id"
}
```

### Demonstrar APIs Administrativas

#### 5. Login Admin
```bash
curl -X POST "http://localhost:8000/v1/api/admin/login" \
  -H "Content-Type: application/json" \
  -d '{
    "username": "admin",
    "password": "admin123"
  }'
```

**Explicar:**
```
"Autentica√ß√£o JWT para acesso √†s funcionalidades administrativas."
```

#### 6. Listar Pedidos (Ordenados) - REQUISITO iv
```bash
curl -X GET "http://localhost:8000/v1/api/admin/pedidos/" \
  -H "Authorization: Bearer {token}"
```

**Explicar:**
```
"Os pedidos s√£o retornados ordenados conforme especifica√ß√£o:
1. Pronto > Em Prepara√ß√£o > Recebido
2. Pedidos mais antigos primeiro
3. Pedidos Finalizados n√£o aparecem na lista"
```

**Resposta Esperada:**
```json
[
  {
    "id": "uuid-1",
    "status": "PRONTO",
    "data_criacao": "2025-01-20T09:00:00",
    "cliente_nome": "Jo√£o Silva",
    "valor_total": 25.50
  },
  {
    "id": "uuid-2", 
    "status": "PREPARANDO",
    "data_criacao": "2025-01-20T09:30:00",
    "cliente_nome": "Maria Santos",
    "valor_total": 18.75
  }
]
```

#### 7. Atualizar Status do Pedido - REQUISITO v
```bash
curl -X PATCH "http://localhost:8000/v1/api/admin/pedidos/{pedido_id}/status" \
  -H "Authorization: Bearer {token}" \
  -H "Content-Type: application/json" \
  -d '{
    "status": "PREPARANDO"
  }'
```

**Explicar:**
```
"Este endpoint permite que a cozinha atualize o status do pedido. 
O fluxo completo √©: RECEBIDO ‚Üí PREPARANDO ‚Üí PRONTO ‚Üí FINALIZADO"
```

---

## üîî 7. DEMONSTRA√á√ÉO DO WEBHOOK (2-3 minutos)

### Simular Webhook do Mercado Pago - REQUISITO iii
```bash
curl -X POST "http://localhost:8000/v1/api/pagamentos/webhook" \
  -H "Content-Type: application/json" \
  -d '{
    "type": "payment",
    "data": {
      "id": "123456789"
    },
    "user_id": 123456,
    "version": "1.0",
    "date_created": "2025-01-20T10:00:00.000-03:00"
  }'
```

**Explicar:**
```
"Este webhook simula a confirma√ß√£o de pagamento do Mercado Pago. 
Quando recebido, o sistema:
1. Consulta o status do pagamento
2. Atualiza o pedido para PAGO se aprovado
3. Permite que a cozinha inicie a prepara√ß√£o"
```

**Resposta Esperada:**
```json
{
  "status": "success",
  "message": "Webhook processado com sucesso. Status: approved",
  "pedido_id": "uuid-do-pedido",
  "payment_id": "123456789"
}
```

### Verificar Status do Pagamento - REQUISITO ii
```bash
curl -X GET "http://localhost:8000/v1/api/pagamentos/{pedido_id}/status" \
  -H "accept: application/json"
```

**Explicar:**
```
"Este endpoint permite consultar se o pagamento foi aprovado ou n√£o, 
conforme especificado nos requisitos."
```

---

## ‚ö° 8. DEMONSTRA√á√ÉO DO HPA (2-3 minutos)

### Simular Carga para Testar Escalabilidade
```bash
# Mostrar como gerar carga para testar HPA
for i in {1..50}; do
  curl -X GET "http://localhost:8000/v1/api/produtos/" &
done
```

### Monitorar HPA em Tempo Real
```bash
# Mostrar escalabilidade autom√°tica
kubectl get hpa -n fastfood -w
kubectl get pods -n fastfood
```

**Explicar:**
```
"Como voc√™s podem ver, o HPA detectou o aumento de carga e escalou 
de 2 para 6 r√©plicas automaticamente. Isso resolve os problemas de 
performance nos hor√°rios de pico, conforme especificado nos requisitos."
```

**Mostrar:**
- üìà **CPU/Memory** aumentando
- üîÑ **Pods** sendo criados automaticamente
- ‚ö° **Tempo de resposta** melhorando
- üìä **M√©tricas** do HPA

---

## üîí 9. VERIFICA√á√ÉO DE SEGURAN√áA (1-2 minutos)

### Mostrar ConfigMap e Secret
```bash
# Mostrar configura√ß√µes (sem expor dados sens√≠veis)
kubectl get configmap -n fastfood
kubectl get secret -n fastfood
```

**Explicar:**
```
"Implementamos boas pr√°ticas de seguran√ßa conforme especificado:
- ConfigMap para vari√°veis de ambiente
- Secret para dados sens√≠veis como senhas e tokens
- Namespace isolado para organiza√ß√£o"
```

### Verificar Configura√ß√µes
```bash
# Mostrar estrutura (sem expor valores)
kubectl describe configmap fastfood-config -n fastfood
kubectl describe secret fastfood-secret -n fastfood
```

---

## üìö 10. DEMONSTRA√á√ÉO DA DOCUMENTA√á√ÉO (1-2 minutos)

### Mostrar README Principal
```
"Vamos ver nossa documenta√ß√£o completa no README."
```

**Apresentar:**
- üìä **Diagrama de arquitetura** integrado
- üìã **Collection Postman** completa
- üìñ **Guia de execu√ß√£o** detalhado
- üîó **Endpoints documentados** com exemplos

### Mostrar Collection Postman
```
"Aqui est√° nossa collection completa do Postman com todos os 
endpoints e exemplos de requisi√ß√£o, conforme solicitado nos requisitos."
```

**Arquivos de Documenta√ß√£o:**
- `README.md` - Documenta√ß√£o principal
- `docs/postman/api_collection.json` - Collection Postman
- `docs/fase2/guia-execucao.md` - Guia completo
- `docs/fase2/mercadopago-integration.md` - Integra√ß√£o Mercado Pago

---

## üéØ 11. CONCLUS√ÉO (1-2 minutos)

### Resumo dos Requisitos Atendidos
```
"Vamos recapitular o que implementamos para a Fase 2:

‚úÖ Clean Architecture com refatora√ß√£o completa do c√≥digo
‚úÖ APIs conforme especifica√ß√£o:
  - Checkout de pedido (recebe produtos, retorna ID)
  - Consulta status de pagamento (aprovado/n√£o)
  - Webhook para confirma√ß√£o de pagamento
  - Listagem ordenada de pedidos (Pronto > Preparando > Recebido)
  - Atualiza√ß√£o de status com valida√ß√µes

‚úÖ Kubernetes com todos os requisitos:
  - HPA para escalabilidade autom√°tica
  - ConfigMap e Secret para seguran√ßa
  - Deployment e Service para exposi√ß√£o
  - Namespace isolado para organiza√ß√£o

‚úÖ Integra√ß√£o Mercado Pago (mock funcional)
‚úÖ Documenta√ß√£o completa com diagramas
‚úÖ Collection Postman com exemplos funcionais"
```

### Demonstra√ß√£o Pr√°tica
```
"Como voc√™s puderam ver, o sistema est√° funcionando perfeitamente:
- APIs respondendo corretamente a todos os requisitos
- HPA escalando automaticamente conforme demanda
- Webhook processando pagamentos adequadamente
- Pedidos sendo gerenciados com ordena√ß√£o correta
- Seguran√ßa implementada com ConfigMap e Secret"
```

### Pr√≥ximos Passos
```
"O sistema est√° pronto para produ√ß√£o e pode ser facilmente 
deployado em qualquer cluster Kubernetes (AKS, EKS, GKE) 
ou plataformas como Render."
```

---

## üìù ROTEIRO DE GRAVA√á√ÉO

### Prepara√ß√£o Pr√©via:
1. ‚úÖ **Minikube funcionando** e limpo
2. ‚úÖ **Imagens Docker** buildadas
3. ‚úÖ **Arquivos YAML** prontos e testados
4. ‚úÖ **Swagger UI** acess√≠vel
5. ‚úÖ **Collection Postman** carregada
6. ‚úÖ **Terminal configurado** com fontes leg√≠veis

### Ordem de Grava√ß√£o:
1. **Introdu√ß√£o** (2-3 min) - Apresenta√ß√£o e contexto
2. **Arquitetura** (3-4 min) - Diagrama e componentes
3. **Minikube Setup** (4-5 min) - Configura√ß√£o inicial
4. **Build/Deploy** (2-3 min) - Constru√ß√£o da aplica√ß√£o
5. **APIs P√∫blicas** (4-5 min) - Testes dos endpoints
6. **APIs Admin** (2-3 min) - Funcionalidades administrativas
7. **Webhook** (2-3 min) - Integra√ß√£o de pagamento
8. **HPA Demo** (2-3 min) - Escalabilidade autom√°tica
9. **Seguran√ßa** (1-2 min) - ConfigMap e Secret
10. **Documenta√ß√£o** (1-2 min) - README e Collection
11. **Conclus√£o** (1-2 min) - Resumo e fechamento

### Dicas para Grava√ß√£o:
- üé• **Use tela cheia** para melhor visualiza√ß√£o
- üîä **Fale claramente** e explique cada passo
- ‚è±Ô∏è **Mantenha ritmo** constante (n√£o muito r√°pido)
- üéØ **Foque nos requisitos** principais da Fase 2
- üîÑ **Teste tudo** antes de gravar
- üìä **Mostre resultados** das APIs
- ‚ö° **Demonstre HPA** em a√ß√£o

### Pontos de Aten√ß√£o:
- **Tempo total:** 20-25 minutos
- **Qualidade:** 1080p ou superior
- **√Åudio:** Claro e sem ru√≠dos
- **Foco:** Requisitos da Fase 2
- **Demonstra√ß√£o:** Funcionalidades reais

---

## üèÜ CRIT√âRIOS DE AVALIA√á√ÉO

### Requisitos Funcionais (40%):
- ‚úÖ Checkout de pedido implementado
- ‚úÖ Consulta status de pagamento
- ‚úÖ Webhook para confirma√ß√£o
- ‚úÖ Listagem ordenada de pedidos
- ‚úÖ Atualiza√ß√£o de status
- ‚úÖ Integra√ß√£o Mercado Pago

### Requisitos de Infraestrutura (40%):
- ‚úÖ Kubernetes configurado
- ‚úÖ HPA implementado
- ‚úÖ ConfigMap e Secret
- ‚úÖ Deployment e Service
- ‚úÖ Namespace isolado

### Documenta√ß√£o (20%):
- ‚úÖ README completo
- ‚úÖ Collection Postman
- ‚úÖ Guia de execu√ß√£o
- ‚úÖ Diagrama de arquitetura

---

**üé¨ Este roteiro garante que todos os requisitos da Fase 2 sejam demonstrados de forma clara e profissional!** 