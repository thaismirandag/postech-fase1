# Design do Banco de Dados - Fase 3

## üéØ **Escolha do Banco: PostgreSQL (RDS)**

### **Justificativa da Escolha:**

1. **Consist√™ncia ACID**: Garante integridade dos dados em transa√ß√µes complexas
2. **Suporte a JSON**: Flexibilidade para dados semi-estruturados
3. **Performance**: Excelente para consultas complexas e relat√≥rios
4. **Escalabilidade**: Suporte a replica√ß√£o e sharding
5. **Maturidade**: Sistema robusto e bem estabelecido
6. **Integra√ß√£o AWS**: RDS oferece backup autom√°tico, patches e monitoramento
7. **Compatibilidade**: Mant√©m compatibilidade com a estrutura atual (SQLAlchemy + Alembic)

## üìä **Modelo de Dados Atualizado**

### **Diagrama ER:**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     CLIENTE     ‚îÇ    ‚îÇ    CATEGORIA    ‚îÇ    ‚îÇ     PRODUTO     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ id (UUID)       ‚îÇ    ‚îÇ id (UUID)       ‚îÇ    ‚îÇ id (UUID)       ‚îÇ
‚îÇ cpf (VARCHAR)   ‚îÇ    ‚îÇ nome (VARCHAR)  ‚îÇ    ‚îÇ nome (VARCHAR)  ‚îÇ
‚îÇ nome (VARCHAR)  ‚îÇ    ‚îÇ descricao (TEXT)‚îÇ    ‚îÇ descricao (TEXT)‚îÇ
‚îÇ email (VARCHAR) ‚îÇ    ‚îÇ ativo (BOOLEAN) ‚îÇ    ‚îÇ preco (DECIMAL) ‚îÇ
‚îÇ ativo (BOOLEAN) ‚îÇ    ‚îÇ created_at      ‚îÇ    ‚îÇ categoria_id    ‚îÇ
‚îÇ created_at      ‚îÇ    ‚îÇ updated_at      ‚îÇ    ‚îÇ ativo (BOOLEAN) ‚îÇ
‚îÇ updated_at      ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ imagem_url      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ               ‚îÇ estoque         ‚îÇ
                              ‚îÇ               ‚îÇ created_at      ‚îÇ
                              ‚îÇ               ‚îÇ updated_at      ‚îÇ
                              ‚îÇ               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ                       ‚îÇ
                              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                      ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     PEDIDO      ‚îÇ    ‚îÇ   ITEM_PEDIDO   ‚îÇ    ‚îÇ   PAGAMENTO     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ id (UUID)       ‚îÇ    ‚îÇ id (UUID)       ‚îÇ    ‚îÇ id (UUID)       ‚îÇ
‚îÇ cliente_id      ‚îÇ    ‚îÇ pedido_id       ‚îÇ    ‚îÇ pedido_id       ‚îÇ
‚îÇ status          ‚îÇ    ‚îÇ produto_id      ‚îÇ    ‚îÇ valor (DECIMAL) ‚îÇ
‚îÇ valor_total     ‚îÇ    ‚îÇ quantidade      ‚îÇ    ‚îÇ status          ‚îÇ
‚îÇ created_at      ‚îÇ    ‚îÇ preco_unitario  ‚îÇ    ‚îÇ preference_id   ‚îÇ
‚îÇ updated_at      ‚îÇ    ‚îÇ created_at      ‚îÇ    ‚îÇ qrcode_url      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ created_at      ‚îÇ
         ‚îÇ                       ‚îÇ            ‚îÇ updated_at      ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üóÉÔ∏è **Esquemas das Tabelas**

### **1. Tabela: `clientes`**
```sql
CREATE TABLE clientes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    cpf VARCHAR(11) UNIQUE NOT NULL,
    nome VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE,
    ativo BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- √çndices
CREATE INDEX idx_clientes_cpf ON clientes(cpf);
CREATE INDEX idx_clientes_email ON clientes(email);
CREATE INDEX idx_clientes_ativo ON clientes(ativo);
```

### **2. Tabela: `categorias`**
```sql
CREATE TABLE categorias (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    nome VARCHAR(100) NOT NULL UNIQUE,
    descricao TEXT,
    ativo BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Dados iniciais
INSERT INTO categorias (nome, descricao) VALUES
    ('Lanche', 'Hamb√∫rgueres, sandu√≠ches e similares'),
    ('Acompanhamento', 'Batatas fritas, saladas e similares'),
    ('Bebida', 'Refrigerantes, sucos e similares'),
    ('Sobremesa', 'Sorvetes, bolos e similares');
```

### **3. Tabela: `produtos`**
```sql
CREATE TABLE produtos (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    nome VARCHAR(255) NOT NULL,
    descricao TEXT,
    preco DECIMAL(10,2) NOT NULL CHECK (preco > 0),
    categoria_id UUID NOT NULL REFERENCES categorias(id),
    ativo BOOLEAN DEFAULT true,
    imagem_url TEXT,
    estoque_disponivel INTEGER DEFAULT 0 CHECK (estoque_disponivel >= 0),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- √çndices
CREATE INDEX idx_produtos_categoria ON produtos(categoria_id);
CREATE INDEX idx_produtos_ativo ON produtos(ativo);
CREATE INDEX idx_produtos_preco ON produtos(preco);
```

### **4. Tabela: `pedidos`**
```sql
CREATE TABLE pedidos (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    cliente_id UUID REFERENCES clientes(id),
    status VARCHAR(50) NOT NULL DEFAULT 'Recebido',
    valor_total DECIMAL(10,2) NOT NULL DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    CONSTRAINT chk_status CHECK (status IN ('Recebido', 'Em prepara√ß√£o', 'Pronto', 'Finalizado'))
);

-- √çndices
CREATE INDEX idx_pedidos_cliente ON pedidos(cliente_id);
CREATE INDEX idx_pedidos_status ON pedidos(status);
CREATE INDEX idx_pedidos_created_at ON pedidos(created_at);
```

### **5. Tabela: `itens_pedido`**
```sql
CREATE TABLE itens_pedido (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    pedido_id UUID NOT NULL REFERENCES pedidos(id) ON DELETE CASCADE,
    produto_id UUID NOT NULL REFERENCES produtos(id),
    quantidade INTEGER NOT NULL CHECK (quantidade > 0),
    preco_unitario DECIMAL(10,2) NOT NULL CHECK (preco_unitario > 0),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- √çndices
CREATE INDEX idx_itens_pedido_pedido ON itens_pedido(pedido_id);
CREATE INDEX idx_itens_pedido_produto ON itens_pedido(produto_id);
```

### **6. Tabela: `pagamentos`**
```sql
CREATE TABLE pagamentos (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    pedido_id UUID NOT NULL REFERENCES pedidos(id),
    valor DECIMAL(10,2) NOT NULL CHECK (valor > 0),
    status VARCHAR(50) NOT NULL DEFAULT 'Pendente',
    preference_id VARCHAR(255),
    qrcode_url TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    CONSTRAINT chk_pagamento_status CHECK (status IN ('Pendente', 'Aprovado', 'Rejeitado', 'Cancelado'))
);

-- √çndices
CREATE INDEX idx_pagamentos_pedido ON pagamentos(pedido_id);
CREATE INDEX idx_pagamentos_status ON pagamentos(status);
```

## üîÑ **Migra√ß√£o da Estrutura Atual**

### **1. Alembic Migrations**
**Atual:**
- ‚úÖ Alembic configurado em `backend/alembic/`
- ‚úÖ Migrations existentes
- ‚úÖ SQLAlchemy models definidos

**Evolu√ß√£o para Fase 3:**
```bash
# Estrutura de migrations para RDS
backend/alembic/
‚îú‚îÄ‚îÄ versions/
‚îÇ   ‚îú‚îÄ‚îÄ 001_initial_schema.py
‚îÇ   ‚îú‚îÄ‚îÄ 002_add_authentication.py
‚îÇ   ‚îî‚îÄ‚îÄ 003_optimize_performance.py
‚îú‚îÄ‚îÄ env.py
‚îú‚îÄ‚îÄ script.py.mako
‚îî‚îÄ‚îÄ alembic.ini
```

### **2. SQLAlchemy Models**
**Atual:**
- ‚úÖ Models em `backend/src/clean_architecture/external/db/models/`
- ‚úÖ Relacionamentos definidos
- ‚úÖ Constraints implementados

**Evolu√ß√£o para Fase 3:**
```python
# Adicionar ao backend/src/clean_architecture/external/db/models/
from sqlalchemy import Column, String, Boolean, DateTime
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func

class ClienteModel(Base):
    __tablename__ = "clientes"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    cpf = Column(String(11), unique=True, nullable=False, index=True)
    nome = Column(String(255), nullable=False)
    email = Column(String(255), unique=True)
    ativo = Column(Boolean, default=True, index=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
```

## üîÑ **Triggers e Functions**

### **1. Trigger para `updated_at`**
```sql
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Aplicar em todas as tabelas
CREATE TRIGGER update_clientes_updated_at BEFORE UPDATE ON clientes FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_produtos_updated_at BEFORE UPDATE ON produtos FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_pedidos_updated_at BEFORE UPDATE ON pedidos FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_pagamentos_updated_at BEFORE UPDATE ON pagamentos FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### **2. Function para calcular valor total do pedido**
```sql
CREATE OR REPLACE FUNCTION calcular_valor_total_pedido(pedido_uuid UUID)
RETURNS DECIMAL AS $$
DECLARE
    total DECIMAL(10,2);
BEGIN
    SELECT COALESCE(SUM(quantidade * preco_unitario), 0)
    INTO total
    FROM itens_pedido
    WHERE pedido_id = pedido_uuid;
    
    UPDATE pedidos SET valor_total = total WHERE id = pedido_uuid;
    RETURN total;
END;
$$ LANGUAGE plpgsql;
```

## üìà **Otimiza√ß√µes de Performance**

### **1. √çndices Compostos**
```sql
-- Para consultas de pedidos por cliente e status
CREATE INDEX idx_pedidos_cliente_status ON pedidos(cliente_id, status);

-- Para consultas de produtos por categoria e pre√ßo
CREATE INDEX idx_produtos_categoria_preco ON produtos(categoria_id, preco);

-- Para consultas de itens por pedido e produto
CREATE INDEX idx_itens_pedido_produto ON itens_pedido(pedido_id, produto_id);
```

### **2. Particionamento (Futuro)**
```sql
-- Particionamento por data para tabela de pedidos (quando crescer)
CREATE TABLE pedidos_2024 PARTITION OF pedidos
FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
```

## üîí **Seguran√ßa**

### **1. Row Level Security (RLS)**
```sql
-- Permitir que clientes vejam apenas seus pr√≥prios pedidos
ALTER TABLE pedidos ENABLE ROW LEVEL SECURITY;

CREATE POLICY pedidos_cliente_policy ON pedidos
    FOR ALL USING (cliente_id = current_setting('app.current_user_id')::UUID);
```

### **2. Encryption**
- **Em tr√¢nsito**: SSL/TLS obrigat√≥rio
- **Em repouso**: Encryption autom√°tica do RDS
- **CPF**: Hash com salt para armazenamento seguro

### **3. Integra√ß√£o com AWS Secrets Manager**
```python
# Evolu√ß√£o do backend/src/clean_architecture/external/db/session.py
import boto3
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

def get_database_url():
    # Buscar credenciais do AWS Secrets Manager
    client = boto3.client('secretsmanager')
    secret = client.get_secret_value(SecretId='/postech/database/credentials')
    credentials = json.loads(secret['SecretString'])
    
    return f"postgresql://{credentials['username']}:{credentials['password']}@{credentials['host']}:{credentials['port']}/{credentials['database']}"

engine = create_engine(get_database_url())
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
```

## üìä **Backup e Recovery**

### **1. Backup Autom√°tico**
- **Backup di√°rio**: Reten√ß√£o de 7 dias
- **Backup semanal**: Reten√ß√£o de 4 semanas
- **Backup mensal**: Reten√ß√£o de 12 meses

### **2. Point-in-Time Recovery**
- **Reten√ß√£o**: 35 dias
- **Granularidade**: 5 minutos

## üîç **Monitoramento**

### **1. M√©tricas Importantes**
- **Connections**: N√∫mero de conex√µes ativas
- **CPU**: Utiliza√ß√£o do processador
- **Memory**: Utiliza√ß√£o de mem√≥ria
- **Storage**: Espa√ßo em disco
- **I/O**: Opera√ß√µes de entrada/sa√≠da

### **2. Alertas**
- **CPU > 80%**: Por 5 minutos
- **Storage > 85%**: Espa√ßo em disco
- **Connections > 80%**: Do limite m√°ximo
- **Replication lag > 30s**: Para read replicas

## üîÑ **Plano de Migra√ß√£o do Banco**

### **Fase 1: Prepara√ß√£o**
1. ‚úÖ Documentar estrutura atual
2. üîÑ Configurar RDS PostgreSQL
3. üîÑ Configurar AWS Secrets Manager
4. üîÑ Testar conectividade

### **Fase 2: Migra√ß√£o**
1. üîÑ Executar migrations no RDS
2. üîÑ Migrar dados existentes (se houver)
3. üîÑ Atualizar configura√ß√µes da aplica√ß√£o
4. üîÑ Testar funcionalidades

### **Fase 3: Otimiza√ß√£o**
1. üîÑ Configurar √≠ndices
2. üîÑ Configurar triggers
3. üîÑ Configurar backup
4. üîÑ Configurar monitoramento

---

**Pr√≥ximo**: Implementar migrations e configurar CI/CD para o banco
